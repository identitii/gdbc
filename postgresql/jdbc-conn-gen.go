// Code generated by gdbc/wrapper
// DO NOT EDIT!

package postgresql

/*
#cgo CFLAGS: -I.
#cgo LDFLAGS: -L. -lgdbc-postgresql
#include <stdlib.h>
#include <./libgdbc-postgresql.h>

// TODO: What are isolates? How do they? WHat do? Huh?
graal_isolatethread_t* postgresqlCreateIsolate() {

  graal_isolate_t *isolate = NULL;
  graal_isolatethread_t *thread = NULL;

  if (graal_create_isolate(NULL, &isolate, &thread) != 0) {
	return NULL;
  }

  return thread;
}

int postgresqlDestroyIsolate(graal_isolatethread_t* thread) {
	return graal_detach_thread(thread);
}
*/
import "C"

import (
	"errors"
	"fmt"
	"log"
	"math/big"
	"strings"
	"time"
	"unsafe"

	"github.com/identitii/gdbc"
)


// EnableTracing turns on trace level logging in the JDBC wrapper. Note: This is applied at connection time
// TODO: Move somewhere else... probably wherever transaction isolation ends up
func EnableTracing(enable bool) {
	tracingEnabled = enable
}

var tracingEnabled = false

func openJdbcConn(url, user, password string, txIsolation gdbc.TransactionIsolation) (*jdbcConn, error) {

	var isolate = C.postgresqlCreateIsolate()

	if tracingEnabled {
		C.enableTracing(isolate, b[true])
	}

	curl, cuser, cpassword := C.CString(url), C.CString(user), C.CString(password)
	defer func() {
		C.free(unsafe.Pointer(curl))
		C.free(unsafe.Pointer(cuser))
		C.free(unsafe.Pointer(cpassword))
	}()

	err := goerr(C.openConnection(isolate, curl, cuser, cpassword, C.int(txIsolation)))
	if err != nil {
		return nil, err
	}

	return &jdbcConn{
		isolate: isolate,
	}, nil
}

type jdbcConn struct {
	isolate *C.graal_isolatethread_t
}

func (c *jdbcConn) Close(keepIsolate bool) error {

	if !keepIsolate {
		defer func() {
			ret := int(C.postgresqlDestroyIsolate(c.isolate))
			if ret != 0 {
				log.Printf("jdbc: warning: failed to destroy isolate on connection close. got return value %d", ret)
			}
		}()
	}

	return goerr(C.closeConnection(c.isolate))
}

func (c *jdbcConn) Begin() error {
	return goerr(C.begin(c.isolate))
}

func (c *jdbcConn) Commit() error {
	return goerr(C.commit(c.isolate))
}

func (c *jdbcConn) Rollback() error {
	return goerr(C.rollback(c.isolate))
}

func (c *jdbcConn) IsValid(timeout int) (valid bool, err error) {
	return int(C.isValid(c.isolate, C.int(timeout))) != 0, c.getLastError()
}

func (c *jdbcConn) getLastError() error {
	return goerr(C.getError(c.isolate))
}

func (c *jdbcConn) Prepare(sql string) (statement int, err error) {
	csql, free := cstring(sql)
	defer free()

	return int(C.prepare(c.isolate, csql)), c.getLastError()
}

func (c *jdbcConn) CloseStatement(statement int) error {
	return goerr(C.closeStatement(c.isolate, C.int(statement)))
}

func (c *jdbcConn) NumInput(statement int) (inputs int, err error) {
	return int(C.numInput(c.isolate, C.int(statement))), c.getLastError()
}

func (c *jdbcConn) Execute(statement int) (updated int, err error) {
	return int(C.execute(c.isolate, C.int(statement))), c.getLastError()
}

func (c *jdbcConn) Query(statement int) (hasResults bool, err error) {
	return int(C.query(c.isolate, C.int(statement))) != 0, c.getLastError()
}

func (c *jdbcConn) Columns(statement int) (columnNames []string, columnTypes []string, err error) {
	columns := C.GoString(C.columns(c.isolate, C.int(statement)))

	err = c.getLastError()
	if err != nil {
		return
	}

	split := strings.Split(columns, "|")

	return strings.Split(split[0], ","), strings.Split(split[1], ","), nil
}

func (c *jdbcConn) Next(statement int) (hasNext bool, err error) {
	return int(C.next(c.isolate, C.int(statement))) != 0, c.getLastError()
}

func (c *jdbcConn) GetMoreResults(statement int) bool {
	return int(C.getMoreResults(c.isolate, C.int(statement))) != 0
}

func (c *jdbcConn) NextResultSet(statement int) bool{
	return int(C.nextResultSet(c.isolate, C.int(statement))) != 0
}

func (c *jdbcConn) SetByte(statement int, index int, value byte) error {
	return goerr(C.setByte(c.isolate, C.int(statement), C.int(index), C.char(value)))
}

func (c *jdbcConn) GetByte(statement int, index int) (byte, error) {
	return byte(C.getByte(c.isolate, C.int(statement), C.int(index))), c.getLastError()
}

func (c *jdbcConn) SetShort(statement int, index int, value int8) error {
	return goerr(C.setShort(c.isolate, C.int(statement), C.int(index), C.short(value)))
}

func (c *jdbcConn) GetShort(statement int, index int) (int8, error) {
	return int8(C.getShort(c.isolate, C.int(statement), C.int(index))), c.getLastError()
}

func (c *jdbcConn) SetInt(statement int, index int, value int32) error {
	return goerr(C.setInt(c.isolate, C.int(statement), C.int(index), C.int(value)))
}

func (c *jdbcConn) GetInt(statement int, index int) (int32, error) {
	return int32(C.getInt(c.isolate, C.int(statement), C.int(index))), c.getLastError()
}

func (c *jdbcConn) SetLong(statement int, index int, value int64) error {
	return goerr(C.setLong(c.isolate, C.int(statement), C.int(index), C.longlong(value)))
}

func (c *jdbcConn) GetLong(statement int, index int) (int64, error) {
	return int64(C.getLong(c.isolate, C.int(statement), C.int(index))), c.getLastError()
}

func (c *jdbcConn) SetFloat(statement int, index int, value float32) error {
	return goerr(C.setFloat(c.isolate, C.int(statement), C.int(index), C.float(value)))
}

func (c *jdbcConn) GetFloat(statement int, index int) (float32, error) {
	return float32(C.getFloat(c.isolate, C.int(statement), C.int(index))), c.getLastError()
}

func (c *jdbcConn) SetDouble(statement int, index int, value float64) error {
	return goerr(C.setDouble(c.isolate, C.int(statement), C.int(index), C.double(value)))
}

func (c *jdbcConn) GetDouble(statement int, index int) (float64, error) {
	return float64(C.getDouble(c.isolate, C.int(statement), C.int(index))), c.getLastError()
}

func (c *jdbcConn) GetBigDecimal(statement int, index int) (float64, error) {
	val := C.GoString(C.getBigDecimal(c.isolate, C.int(statement), C.int(index)))
	if err := c.getLastError(); err != nil {
		return 0, err
	}
	rational := big.NewRat(0, 1)
	_, ok := rational.SetString(val)
	if !ok {
		return 0, fmt.Errorf("failed to read bigdecimal from string '%s'", val)
	}
	f, _ := rational.Float64()
	return f, nil
}

func (c *jdbcConn) SetString(statement int, index int, value string) error {
	cvalue, free := cstring(value)
	defer free()

	return goerr(C.setString(c.isolate, C.int(statement), C.int(index), cvalue))
}

func (c *jdbcConn) GetString(statement int, index int) (string, error) {
	return C.GoString(C.getString(c.isolate, C.int(statement), C.int(index))), c.getLastError()
}

func (c *jdbcConn) SetTimestamp(statement int, index int, value time.Time) error {
	return goerr(C.setTimestamp(c.isolate, C.int(statement), C.int(index), C.longlong(value.Unix())))
}

func (c *jdbcConn) GetTimestamp(statement int, index int) (time.Time, error) {
	t := int64(C.getTimestamp(c.isolate, C.int(statement), C.int(index)))
	if err := c.getLastError(); err != nil {
		return time.Unix(0, 0), err
	}
	return time.Unix(t, 0), nil
}

func (c *jdbcConn) SetNull(statement int, index int) error {
	return goerr(C.setNull(c.isolate, C.int(statement), C.int(index)))
}

// TestQueryJSON is a quick way to run a query during testing. The resultset is returned as a json array.
func (c *jdbcConn) TestQueryJSON(query string) (string, error) {
	cquery, free := cstring(query)
	defer free()

	result := C.GoString(C.testQueryJSON(c.isolate, cquery))

	return result, c.getLastError()
}

var b = map[bool]C.int{
	false: C.int(0),
	true:  C.int(1),
}

func goerr(ce *C.char) error {
	s := C.GoString(ce)
	if s == "" {
		return nil
	}
	return errors.New(s)
}

func cstring(s string) (*C.char, func()) {
	cs := C.CString(s)
	return cs, func() {
		C.free(unsafe.Pointer(cs))
	}
}
